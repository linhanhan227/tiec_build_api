# TieCloud Build API - 代码深度解析

## 目录
1. [核心模块详解](#核心模块详解)
2. [API 实现分析](#api-实现分析)
3. [Worker 任务处理](#worker-任务处理)
4. [数据库操作](#数据库操作)
5. [限流中间件](#限流中间件)
6. [关键代码片段](#关键代码片段)

---

## 核心模块详解

### 1. main.rs - 应用入口（218 行）

**职责**：
- 初始化运行时配置
- 加载和验证嵌入式资源
- 启动工作线程和清理任务
- 配置中间件和路由
- 启动 HTTP 服务器

**关键流程**：

```rust
#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // 1. 配置日志（仅 error 级别避免输出过多）
    std::env::set_var("RUST_LOG", "error");
    env_logger::init();

    // 2. 加载环境变量
    let config = Config::from_env();

    // 3. 确定资源位置
    let exe_dir = std::env::current_exe()
        .ok()
        .and_then(|p| p.parent().map(|p| p.to_path_buf()))
        .unwrap_or_else(|| std::path::PathBuf::from("."));
    
    let tiec_root = exe_dir.join(".tiec");
    let upload_dir = if Path::new(&config.upload_dir).is_absolute() {
        config.upload_dir.clone()
    } else {
        exe_dir.join(&config.upload_dir).to_string_lossy().to_string()
    };

    // 4. 初始化数据库
    let database = Database::new(&database_path)
        .expect("Failed to initialize database");

    // 5. 创建应用状态
    let state = web::Data::new(AppState::new(
        upload_dir.clone(),
        tiec_dir.to_string_lossy().to_string(),
        stdlib_dir.to_string_lossy().to_string(),
        config.queue_capacity,
        database,
    ));

    // 6. 提取嵌入式资源
    if let Err(e) = state.ensure_assets_extracted() {
        panic!("Failed to extract assets: {}", e);
    }

    // 7. 恢复历史任务
    state.load_tasks_from_db().await.expect("Failed to load tasks");

    // 8. 启动 Worker 线程池
    for i in 0..config.worker_count {
        let state_clone = state.clone();
        let task_queue_worker = task_queue_clone.clone();
        tokio::spawn(async move {
            worker::run_worker(state_clone.into_inner(), task_queue_worker, i, task_timeout).await;
        });
    }

    // 9. 启动定期清理任务
    tokio::spawn(async move {
        worker::cleanup_task(cleanup_state.into_inner(), cleanup_interval, task_timeout).await;
    });

    // 10. 启动 Actix-web 服务器
    HttpServer::new(move || {
        App::new()
            .wrap(ip_limiter_clone)
            .wrap(hourly_limiter.clone())
            .wrap(Governor::new(&governor_conf))
            .wrap(Cors::permissive())
            .wrap(Logger::default())
            .app_data(state_clone.clone())
            .service(api::health::health_check)
            .service(api::upload::upload_file)
            .service(api::build::create_build)
            .service(api::build::get_build_status)
            .service(api::build::get_build_events)
            .service(api::download::download_build)
            .service(SwaggerUi::new("/swagger-ui/{_:.*}")
                .url("/api-docs/openapi.json", ApiDoc::openapi()))
    })
    .bind(format!("{}:{}", config.host, config.port))?
    .run()
    .await
}
```

**本地 IP 检测**：
```rust
#[cfg(not(windows))]
fn get_local_ips() -> Vec<String> {
    let mut ips = Vec::new();
    if let Ok(ifaces) = get_if_addrs::get_if_addrs() {
        for iface in ifaces {
            if iface.is_loopback() {
                continue;
            }
            match iface.ip() {
                IpAddr::V4(ip) => ips.push(ip.to_string()),
                _ => {}
            }
        }
    }
    ips.sort();
    ips.dedup();
    ips
}
```

---

### 2. config.rs - 环境变量管理

**数据结构**：
```rust
pub struct Config {
    pub host: String,                // 监听地址
    pub port: u16,                   // 监听端口
    pub upload_dir: String,          // 上传目录
    pub database_path: String,       // 数据库路径
    pub queue_capacity: usize,       // 队列容量
    pub worker_count: usize,         // Worker 数量
    pub task_timeout: u64,           // 任务超时（秒）
    pub cleanup_interval: u64,       // 清理间隔（秒）
    pub hourly_ip_limit: u32,        // 小时级 IP 限制
}

impl Config {
    pub fn from_env() -> Self {
        Self {
            host: std::env::var("HOST")
                .unwrap_or_else(|_| "0.0.0.0".into()),
            port: std::env::var("PORT")
                .unwrap_or_else(|_| "8080".into())
                .parse()
                .unwrap_or(8080),
            // ... 其他字段类似
        }
    }
}
```

**特点**：
- 所有配置都有默认值
- 类型解析失败时回退到默认值
- 支持相对路径和绝对路径

---

### 3. state.rs - 全局应用状态

**核心数据结构**：
```rust
pub struct AppState {
    pub tasks: dashmap::DashMap<Uuid, Task>,      // 内存缓存
    pub upload_dir: String,
    pub tiecc_dir: String,
    pub stdlib_dir: String,
    pub queue_capacity: usize,
    pub database: Database,
    // 统计计数器
    pub total_tasks: AtomicU64,
    pub completed_tasks: AtomicU64,
    pub failed_tasks: AtomicU64,
    pub active_workers: AtomicU64,
}
```

**关键方法**：

```rust
// 从数据库加载历史任务
pub async fn load_tasks_from_db(&self) -> Result<(), Box<dyn std::error::Error>> {
    let db_tasks = self.database.get_all_tasks().await?;
    for task in db_tasks {
        self.tasks.insert(task.task_id, task);
    }
    let (total, completed, failed, _) = self.database.get_task_stats().await?;
    self.total_tasks.store(total, std::sync::atomic::Ordering::Relaxed);
    self.completed_tasks.store(completed, std::sync::atomic::Ordering::Relaxed);
    self.failed_tasks.store(failed, std::sync::atomic::Ordering::Relaxed);
    Ok(())
}

// 入队任务
pub async fn enqueue_task(&self, task_id: Uuid, max_queue_size: usize) {
    if let Some(mut task) = self.tasks.get_mut(&task_id) {
        task.status = crate::models::TaskStatus::Queued;
        task.current_step = Some("Queued".into());
        task.updated_at = chrono::Utc::now();
    }
    self.enforce_queue_capacity(max_queue_size).await;
    if let Err(e) = self.database.enqueue_task(&task_id).await {
        log::error!("Failed to enqueue task {}: {}", task_id, e);
    }
}

// 队列溢出处理：删除最早的任务
pub async fn enforce_queue_capacity(&self, max_queue_size: usize) {
    let mut queued_count = match self.database.count_queued_tasks().await {
        Ok(count) => count as usize,
        Err(e) => {
            log::error!("Failed to count queued tasks: {}", e);
            return;
        }
    };

    if queued_count >= max_queue_size {
        let overflow = (queued_count + 1).saturating_sub(max_queue_size).max(1);
        match self.database.get_oldest_queued_tasks(overflow as u64).await {
            Ok(old_tasks) => {
                for old_task_id in old_tasks {
                    if let Some(mut task) = self.tasks.get_mut(&old_task_id) {
                        task.status = crate::models::TaskStatus::Cancelled;
                        task.error = Some("Cancelled due to queue overflow".into());
                        task.updated_at = chrono::Utc::now();
                        log::warn!("Cancelled task {} due to queue overflow", old_task_id);
                    }
                    if let Err(e) = self.database.cancel_task(&old_task_id, "...").await {
                        log::error!("Failed to cancel task {}: {}", old_task_id, e);
                    }
                }
            }
            Err(e) => {
                log::error!("Failed to fetch queued tasks: {}", e);
            }
        }
    }
}

// 资源提取：嵌入式 ZIP 解包
pub fn ensure_assets_extracted(&self) -> Result<(), Box<dyn std::error::Error>> {
    let tiecc_path = std::path::Path::new(&self.tiecc_dir);
    let stdlib_path = std::path::Path::new(&self.stdlib_dir);
    let root_dir = tiecc_path.parent().unwrap_or(std::path::Path::new("./.tiec"));

    if !tiecc_path.exists() || !stdlib_path.exists() {
        log::info!("Assets missing. Initializing embedded assets to {:?}", root_dir);
        std::fs::create_dir_all(root_dir)?;

        // 遍历 ASSETS 常量（在 build.rs 中生成）
        for asset in ASSETS {
            let target = root_dir.join(asset.path);
            if let Some(parent) = target.parent() {
                std::fs::create_dir_all(parent)?;
            }
            std::fs::write(&target, asset.data)?;

            // 设置 Unix 权限（如可执行）
            #[cfg(unix)]
            if let Some(mode) = asset.unix_mode {
                use std::os::unix::fs::PermissionsExt;
                let mut perms = std::fs::metadata(&target)?.permissions();
                perms.set_mode(mode);
                std::fs::set_permissions(&target, perms)?;
            }
        }
        log::info!("Assets initialized successfully");
    }
    Ok(())
}
```

**关键特性**：
- **DashMap**：无锁并发 HashMap，高效读取
- **原子计数**：使用 `AtomicU64` 避免锁竞争
- **队列管理**：溢出时自动删除最旧任务
- **资源管理**：自动从内置 ZIP 提取编译工具

---

## API 实现分析

### 1. upload.rs - 文件上传（172 行）

**处理流程**：

```
接收 multipart 请求
    ↓
验证 Content-Disposition（获取文件名）
    ↓
检查扩展名（必须 .tsp）
    ↓
检查 MIME 类型（application/zip 等）
    ↓
创建临时文件 ({temp_id}.uploading)
    ↓
流式读取 + 计算 SHA1 + 检查大小（≤100MB）
    ↓
验证 ZIP 完整性
    ↓
重命名为最终文件 ({sha1}.tsp)
    ↓
自动解压到 {file_id}_extracted/
    ↓
返回 { file_id: "sha1hex" }
```

**关键代码片段**：

```rust
#[post("/upload")]
pub async fn upload_file(
    _req: HttpRequest,
    mut payload: Multipart,
    data: web::Data<AppState>,
) -> Result<impl Responder, ApiError> {
    let mut file_id = None;

    while let Ok(Some(mut field)) = payload.try_next().await {
        // 验证文件名
        let content_disposition = field.content_disposition()
            .ok_or(ApiError::BadRequest("Missing Content-Disposition".into()))?;
        let filename = content_disposition.get_filename().unwrap_or("unknown");
        if !filename.to_lowercase().ends_with(".tsp") {
             return Err(ApiError::UploadError(
                 "Invalid file extension. Only .tsp files are allowed.".into()
             ));
        }

        // 验证 MIME 类型
        let content_type = field.content_type();
        if let Some(mime) = content_type {
            let is_zip = mime.type_() == mime::APPLICATION
                && (mime.subtype() == "zip"
                    || mime.subtype() == "x-zip-compressed"
                    || mime.subtype() == "octet-stream");
            if !is_zip {
                return Err(ApiError::UploadError(
                    "Invalid file type. Only .tsp (zip) files are allowed.".into()
                ));
            }
        }

        let temp_id = Uuid::new_v4();
        let temp_filepath = format!("{}/{}.uploading", data.upload_dir, temp_id);

        // 流式读取 + SHA1 计算
        let mut f = web::block(move || std::fs::File::create(temp_filepath_clone))
            .await
            .map_err(|_e| ApiError::InternalServerError)?
            .map_err(|_e| ApiError::InternalServerError)?;

        let mut size = 0;
        let mut hasher = Sha1::new();
        while let Some(chunk) = field.next().await {
            let data = chunk.map_err(|_| ApiError::UploadError("Transfer error".into()))?;
            size += data.len();
            if size > 100 * 1024 * 1024 { // 100MB 限制
                 let _ = std::fs::remove_file(&temp_filepath);
                 return Err(ApiError::UploadError("File too large. Max 100MB.".into()));
            }
            hasher.update(&data);
            f = web::block(move || f.write_all(&data).map(|_| f))
                .await
                .map_err(|_e| ApiError::InternalServerError)?
                .map_err(|_e| ApiError::InternalServerError)?;
        }

        let sha1_hex = format!("{:x}", hasher.finalize());
        let final_filepath = format!("{}/{}.tsp", data.upload_dir, sha1_hex);

        // ZIP 完整性验证
        let filepath_verify = temp_filepath.clone();
        let integrity_check = web::block(move || {
            let file = std::fs::File::open(&filepath_verify)?;
            let archive = zip::ZipArchive::new(file)?;
            if archive.len() == 0 {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData, 
                    "Empty zip"
                ));
            }
            Ok::<(), std::io::Error>(())
        }).await;

        match integrity_check {
             Ok(Ok(_)) => {},
             _ => {
                 let _ = std::fs::remove_file(&temp_filepath);
                 return Err(ApiError::UploadError("Corrupted or invalid ZIP file.".into()));
             }
        }

        // 移动到最终位置
        let _ = std::fs::rename(&temp_filepath, &final_filepath);

        // 自动解压
        let final_filepath_clone = final_filepath.clone();
        let extracted_dir = format!("{}/{}_extracted", data.upload_dir, sha1_hex);
        let extracted_dir_clone = extracted_dir.clone();

        let unzip_result = web::block(move || -> Result<(), std::io::Error> {
            let file = std::fs::File::open(&final_filepath_clone)?;
            let mut archive = zip::ZipArchive::new(file)?;
            extract_zip_from_archive(&mut archive, std::path::Path::new(&extracted_dir_clone))?;
            Ok(())
        }).await;

        match unzip_result {
            Ok(Ok(_)) => {
                file_id = Some(sha1_hex);
            }
            _ => {
                return Err(ApiError::InternalServerError);
            }
        }
    }

    if let Some(id) = file_id {
        Ok(json_response(UploadResponse { file_id: id }))
    } else {
        Err(ApiError::BadRequest("No file uploaded".into()))
    }
}
```

**安全特性**：
- ✅ 临时文件方案：避免部分上传污染
- ✅ 大小限制：100MB 上限
- ✅ SHA1 哈希：文件完整性和去重
- ✅ ZIP 验证：防止损坏文件
- ✅ 类型白名单：只接受 .tsp

---

### 2. build.rs - 构建任务创建

**流程**：

```rust
#[post("/build")]
pub async fn create_build(
    req: HttpRequest,
    build_req: web::Json<BuildRequest>,
    data: web::Data<AppState>,
) -> Result<impl Responder, ApiError> {
    let file_id_str = &build_req.file_id;
    
    // 验证 file_id 格式：40 位十六进制
    if file_id_str.len() != 40 || !file_id_str.chars().all(|c| c.is_ascii_hexdigit()) {
        return Err(ApiError::BadRequest("Invalid File ID format".into()));
    }

    let user_id = get_client_ip(&req);  // 获取客户端 IP

    // 检查文件是否存在（未提取或已提取）
    let extracted_dir = format!("{}/{}_extracted", data.upload_dir, file_id_str);
    let tsp_path = format!("{}/{}.tsp", data.upload_dir, file_id_str);
    let file_path = if std::path::Path::new(&extracted_dir).exists() {
        extracted_dir
    } else if std::path::Path::new(&tsp_path).exists() {
        tsp_path
    } else {
        return Err(ApiError::NotFound("File not found or expired".into()));
    };

    // 检查是否存在未完成的同文件任务（复用逻辑）
    if let Ok(Some(existing_task)) = data.database
        .find_latest_task_by_file_id_and_user_id(file_id_str, &user_id)
        .await 
    {
        match existing_task.status {
            TaskStatus::Failed | TaskStatus::Cancelled => {
                // 允许重新构建
            }
            _ => {
                // 返回现有任务
                return Ok(accepted_json_response(BuildResponse {
                    task_id: existing_task.task_id.to_string(),
                    status: existing_task.status,
                }));
            }
        }
    }

    // 创建新任务
    let task_id = Uuid::new_v4();
    let task = Task {
        task_id,
        status: TaskStatus::Queued,
        progress: 0,
        estimated_time_remaining: None,
        current_step: Some("Queued".into()),
        error: None,
        created_at: Utc::now(),
        updated_at: Utc::now(),
        retry_count: 0,
        max_retries: 3,
        build_duration: None,
        priority: 0,
        file_id: file_id_str.to_string(),
        file_path: file_path.clone(),
        output_path: None,
        user_id,
    };

    // 内存缓存 + 数据库保存
    data.tasks.insert(task_id, task.clone());
    data.total_tasks.fetch_add(1, Ordering::Relaxed);

    if let Err(e) = data.save_task_to_db(&task).await {
        log::error!("Failed to save task to database: {}", e);
        return Err(ApiError::InternalServerError);
    }
    
    // 入队
    data.enqueue_task(task_id, data.queue_capacity).await;

    Ok(accepted_json_response(BuildResponse {
        task_id: task_id.to_string(),
        status: TaskStatus::Queued,
    }))
}
```

**HTTP 状态码**：
- **202 Accepted**：任务已创建，处理中
- **400 Bad Request**：file_id 格式错误
- **404 Not Found**：文件不存在

---

## Worker 任务处理

### worker/mod.rs - 后台任务执行器（462 行）

**主 Worker 循环**：

```rust
pub async fn run_worker(data: Arc<AppState>, task_queue: Arc<tokio::sync::Mutex<VecDeque<Uuid>>>, 
                        worker_id: usize, task_timeout: u64) {
    log::info!("Worker {} started", worker_id);
    let worker_id_str = format!("worker-{}", worker_id);
    let lease_refresh_secs = std::cmp::max(5, task_timeout / 2);

    loop {
        // 1. 租赁下一个任务
        let task_id = match data.database.lease_next_task(&worker_id_str, task_timeout + 60).await {
            Ok(Some(id)) => id,
            Ok(None) => {
                tokio::time::sleep(std::time::Duration::from_millis(200)).await;
                continue;
            }
            Err(e) => {
                log::error!("Failed to lease task: {}", e);
                tokio::time::sleep(std::time::Duration::from_millis(500)).await;
                continue;
            }
        };

        log::info!("Processing task: {}", task_id);

        // 2. 启动租约续约后台任务
        let lease_task_id = task_id;
        let lease_data = data.clone();
        let lease_worker = worker_id_str.clone();
        let lease_handle = tokio::spawn(async move {
            let mut interval = tokio::time::interval(
                std::time::Duration::from_secs(lease_refresh_secs)
            );
            loop {
                interval.tick().await;
                if let Err(e) = lease_data.database.refresh_lease(
                    &lease_task_id, 
                    &lease_worker, 
                    task_timeout + 60
                ).await {
                    log::warn!("Failed to refresh lease for task {}: {}", lease_task_id, e);
                }
            }
        });
        
        // 3. 更新为处理中
        update_task_status(&data, &task_id, TaskStatus::Processing, 5, 
                          Some("Initializing environment".into()), None).await;

        // 4. 准备项目目录
        let (file_path, _user_id) = if let Some(task) = data.tasks.get(&task_id) {
            (task.file_path.clone(), task.user_id.clone())
        } else {
            stop_lease(&data, &task_id, &lease_handle).await;
            continue;
        };

        let mut project_dir = file_path.clone();

        // 5. 解压（如果是 ZIP 文件）
        if !std::path::Path::new(&file_path).is_dir() {
            let file_stem = std::path::Path::new(&file_path)
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("unknown");
            let unzip_dir = format!("{}/{}_extracted", data.upload_dir, file_stem);

            update_progress(&data, task_id, 10, "Extracting project...").await;

            // ... 解压逻辑 ...

            project_dir = unzip_dir.clone();
        }

        // 6. 构建工程配置
        update_progress(&data, task_id, 20, "Preparing build environment...").await;
        
        let mut build_json = json!({
            "appName": "TieCloud App",
            "appIcon": "icon.png",
            "minSdk": 21,
            "targetSdk": 34,
            "versionCode": 1,
            "versionName": "1.0.0"
        });

        // ... 读取自定义配置（如存在）...

        let project_json_path = format!("{}/project.json", project_dir);
        if let Err(e) = std::fs::write(&project_json_path, build_json.to_string()) {
            fail_task(&data, task_id, format!("Failed to write project.json: {}", e)).await;
            stop_lease(&data, &task_id, &lease_handle).await;
            continue;
        }

        // 7. 执行编译
        update_progress(&data, task_id, 30, "Starting compiler...").await;

        let tiecc_bin = if cfg!(target_os = "windows") {
            format!("{}/tiec.exe", data.tiecc_dir)
        } else {
            format!("{}/tiec", data.tiecc_dir)
        };

        let compile_cmd = vec![
            &tiecc_bin,
            "-o", "/build",
            "--platform", "android",
            "--android.gradle",
            "--android.app.config", &project_json_path,
            "--release",
            "--log-level", "error",
            "--dir", &project_dir,
        ];

        let mut child = match Command::new(&tiecc_bin)
            .args(&compile_cmd[1..])
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
        {
            Ok(c) => c,
            Err(e) => {
                fail_task(&data, task_id, format!("Failed to spawn compiler: {}", e)).await;
                stop_lease(&data, &task_id, &lease_handle).await;
                continue;
            }
        };

        // 8. 实时读取编译输出
        if let Some(stdout) = child.stdout.take() {
            let reader = BufReader::new(stdout);
            let mut lines = reader.lines();

            while let Ok(Some(line)) = lines.next_line().await {
                let trimmed = line.trim();
                if !trimmed.is_empty() {
                    // 更新进度和日志
                    update_progress(&data, task_id, 50, trimmed).await;
                    
                    // 记录事件
                    if let Err(e) = data.database.insert_task_event(
                        &task_id, "log", None, Some(trimmed), Some(&worker_id_str)
                    ).await {
                        log::warn!("Failed to write task event: {}", e);
                    }
                }
            }
        }

        // 9. 等待编译完成
        let compile_timeout = Duration::from_secs(task_timeout);
        let status = match wait_timeout::wait_child_timeout(&mut child, compile_timeout) {
            Ok(Some(status)) => status,
            Ok(None) => {
                // 超时
                let _ = child.kill().await;
                fail_task(&data, task_id, "Compilation timeout".into()).await;
                stop_lease(&data, &task_id, &lease_handle).await;
                continue;
            }
            Err(e) => {
                fail_task(&data, task_id, format!("Failed to wait for compiler: {}", e)).await;
                stop_lease(&data, &task_id, &lease_handle).await;
                continue;
            }
        };

        // 10. 处理编译结果
        if status.success() {
            // 查找 APK 输出文件
            let build_dir = format!("{}/build", project_dir);
            let apk_path = find_apk(&build_dir);

            if let Some(apk) = apk_path {
                // 成功
                update_task_status(&data, &task_id, TaskStatus::Success, 100,
                                  Some("Build completed".into()), None).await;
                
                if let Some(mut task) = data.tasks.get_mut(&task_id) {
                    task.output_path = Some(apk.clone());
                    task.build_duration = Some(/* elapsed time */);
                    data.completed_tasks.fetch_add(1, Ordering::Relaxed);
                }
            } else {
                fail_task(&data, task_id, "APK file not found in output".into()).await;
            }
        } else {
            // 编译失败
            fail_task(&data, task_id, "Compilation failed".into()).await;
            
            // 判断是否重试
            if let Some(mut task) = data.tasks.get_mut(&task_id) {
                if task.retry_count < task.max_retries {
                    task.retry_count += 1;
                    task.status = TaskStatus::Queued;
                    task.next_run_at = Some(/* future time */);
                    log::info!("Task {} queued for retry {}/{}", task_id, task.retry_count, task.max_retries);
                }
            }
        }

        // 11. 清理租约
        stop_lease(&data, &task_id, &lease_handle).await;
    }
}
```

**关键特性**：
- **租约机制**：防止多个 Worker 处理同一任务
- **续约**：定期更新租约时间，防止其他 Worker 抢占
- **实时日志**：流式读取编译输出，逐行保存到数据库
- **超时管理**：使用 `wait_timeout` crate 处理进程超时
- **重试逻辑**：失败时判断是否可重试

---

## 数据库操作

### database.rs - SQLite 管理（919 行）

**初始化和迁移**：

```rust
impl Database {
    pub fn new(db_path: &str) -> Result<Self> {
        // 确保父目录存在
        if let Some(parent) = std::path::Path::new(db_path).parent() {
            std::fs::create_dir_all(parent).expect("Failed to create database directory");
        }

        let conn = Connection::open(db_path)?;
        Self::init_tables(&conn)?;
        Ok(Database {
            conn: Arc::new(Mutex::new(conn)),
        })
    }

    fn init_tables(conn: &Connection) -> Result<()> {
        // 创建迁移表
        conn.execute(
            "CREATE TABLE IF NOT EXISTS schema_migrations (
                version INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                applied_at TEXT NOT NULL
            )",
            [],
        )?;

        // 执行迁移
        Self::run_migrations(conn)?;
        Ok(())
    }

    fn run_migrations(conn: &Connection) -> Result<()> {
        let current_version: i64 = conn.query_row(
            "SELECT COALESCE(MAX(version), 0) FROM schema_migrations",
            [],
            |row| row.get(0),
        ).unwrap_or(0);

        // Migration 1: 创建 tasks 表
        if current_version < 1 {
            conn.execute(
                "CREATE TABLE IF NOT EXISTS tasks (
                    task_id TEXT PRIMARY KEY,
                    status TEXT NOT NULL,
                    progress INTEGER NOT NULL DEFAULT 0,
                    estimated_time_remaining INTEGER,
                    current_step TEXT,
                    error TEXT,
                    created_at TEXT NOT NULL,
                    updated_at TEXT NOT NULL,
                    retry_count INTEGER NOT NULL DEFAULT 0,
                    max_retries INTEGER NOT NULL DEFAULT 3,
                    build_duration INTEGER,
                    priority INTEGER NOT NULL DEFAULT 0,
                    file_path TEXT NOT NULL,
                    output_path TEXT,
                    user_id TEXT NOT NULL
                )",
                [],
            )?;
            conn.execute(
                "INSERT INTO schema_migrations (version, name, applied_at) VALUES (?, ?, ?)",
                rusqlite::params![1, "create_tasks_table", chrono::Utc::now().to_rfc3339()],
            )?;
        }

        // Migration 2: 添加 build_duration 列
        if current_version < 2 {
            if !Self::column_exists(conn, "tasks", "build_duration")? {
                conn.execute(
                    "ALTER TABLE tasks ADD COLUMN build_duration INTEGER",
                    [],
                )?;
            }
            // ... 记录迁移 ...
        }

        // Migration 3-4: 添加租约相关列
        // ...
    }
}
```

**关键查询操作**：

```rust
// 租赁下一个任务
pub async fn lease_next_task(&self, worker_id: &str, lease_duration_secs: u64) -> Result<Option<Uuid>, Box<dyn std::error::Error>> {
    let conn = self.conn.lock().await;
    let now = Utc::now();
    let lease_until = now + Duration::seconds(lease_duration_secs as i64);

    let mut stmt = conn.prepare(
        "UPDATE tasks 
         SET locked_by = ?, lease_until = ?
         WHERE task_id = (
             SELECT task_id FROM tasks 
             WHERE status = '排队中' 
             AND (locked_by IS NULL OR lease_until < ?)
             ORDER BY priority DESC, created_at ASC
             LIMIT 1
         )
         RETURNING task_id"
    )?;

    let result = stmt.query_row(
        rusqlite::params![worker_id, lease_until.to_rfc3339(), now.to_rfc3339()],
        |row| row.get::<_, String>(0),
    ).optional()?;

    Ok(result.map(|s| Uuid::parse_str(&s).unwrap_or_else(|_| Uuid::new_v4())))
}

// 续约租约
pub async fn refresh_lease(&self, task_id: &Uuid, worker_id: &str, lease_duration_secs: u64) -> Result<(), Box<dyn std::error::Error>> {
    let conn = self.conn.lock().await;
    let lease_until = Utc::now() + Duration::seconds(lease_duration_secs as i64);
    
    conn.execute(
        "UPDATE tasks SET lease_until = ? WHERE task_id = ? AND locked_by = ?",
        rusqlite::params![lease_until.to_rfc3339(), task_id.to_string(), worker_id],
    )?;
    
    Ok(())
}

// 清理租约
pub async fn clear_lease(&self, task_id: &Uuid) -> Result<(), Box<dyn std::error::Error>> {
    let conn = self.conn.lock().await;
    conn.execute(
        "UPDATE tasks SET locked_by = NULL, lease_until = NULL WHERE task_id = ?",
        rusqlite::params![task_id.to_string()],
    )?;
    Ok(())
}

// 获取任务统计
pub async fn get_task_stats(&self) -> Result<(i64, i64, i64, i64), Box<dyn std::error::Error>> {
    let conn = self.conn.lock().await;
    
    let total: i64 = conn.query_row(
        "SELECT COUNT(*) FROM tasks",
        [],
        |row| row.get(0),
    )?;

    let completed: i64 = conn.query_row(
        "SELECT COUNT(*) FROM tasks WHERE status = '成功'",
        [],
        |row| row.get(0),
    )?;

    let failed: i64 = conn.query_row(
        "SELECT COUNT(*) FROM tasks WHERE status = '失败'",
        [],
        |row| row.get(0),
    )?;

    let queued: i64 = conn.query_row(
        "SELECT COUNT(*) FROM tasks WHERE status = '排队中'",
        [],
        |row| row.get(0),
    )?;

    Ok((total, completed, failed, queued))
}
```

---

## 限流中间件

### middleware.rs - IP 限流与小时级限制

**秒级限流 (IpRateLimiter)**：

```rust
#[derive(Clone)]
pub struct IpRateLimiter {
    request_counts: Arc<RwLock<HashMap<String, (u32, Instant)>>>,
    ban_file_path: PathBuf,
    rate_limit: u32,           // 每秒请求数
    ban_duration: Duration,    // 封禁时长
}

impl IpRateLimiter {
    pub async fn is_blocked(&self, ip: &str) -> Result<bool, Box<dyn std::error::Error>> {
        if !self.ban_file_path.exists() {
            return Ok(false);
        }

        let content = fs::read_to_string(&self.ban_file_path).await?;
        let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();

        for line in content.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            // 格式：IP:timestamp
            if let Some((banned_ip, timestamp_str)) = line.split_once(':') {
                if banned_ip == ip {
                    if let Ok(timestamp) = timestamp_str.parse::<u64>() {
                        let elapsed = now.saturating_sub(timestamp);
                        if elapsed < self.ban_duration.as_secs() {
                            return Ok(true);  // 仍在封禁期
                        }
                    }
                }
            }
        }

        Ok(false)
    }

    pub async fn add_banned_ip(&self, ip: &str) -> Result<(), Box<dyn std::error::Error>> {
        let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
        
        let mut content = if self.ban_file_path.exists() {
            fs::read_to_string(&self.ban_file_path).await?
        } else {
            "# IP Ban List - Auto-generated\n# Format: IP_ADDRESS:TIMESTAMP\n\n".to_string()
        };

        // 添加或更新封禁记录
        let mut lines: Vec<String> = content.lines().map(|s| s.to_string()).collect();
        let mut found = false;
        for line in &mut lines {
            if line.contains(&format!("{}:", ip)) || line == ip {
                *line = format!("{}:{}", ip, now);
                found = true;
                break;
            }
        }

        if !found {
            content.push_str(&format!("{}:{}\n", ip, now));
        } else {
            content = lines.join("\n") + "\n";
        }

        fs::write(&self.ban_file_path, content).await?;
        log::warn!("IP {} banned for {} days", ip, self.ban_duration.as_secs() / (24 * 60 * 60));
        Ok(())
    }
}
```

**小时级限流 (HourlyIpLimiter)**：

```rust
#[derive(Clone)]
pub struct HourlyIpLimiter {
    limits: Arc<RwLock<HashMap<String, Vec<Instant>>>>,
    limit_per_hour: u32,
}

impl HourlyIpLimiter {
    pub fn new(limit_per_hour: u32) -> Self {
        Self {
            limits: Arc::new(RwLock::new(HashMap::new())),
            limit_per_hour,
        }
    }

    pub async fn check_and_update(&self, ip: &str) -> bool {
        let mut limits = self.limits.write().await;
        let now = Instant::now();
        
        let entry = limits.entry(ip.to_string()).or_insert_with(Vec::new);
        
        // 清理 1 小时外的请求
        entry.retain(|t| now.duration_since(*t).as_secs() < 3600);
        
        if entry.len() >= self.limit_per_hour as usize {
            return false;  // 超限
        }
        
        entry.push(now);
        true
    }
}
```

**中间件注册**：

```rust
// 在 main.rs 中
let ip_limiter = middleware::IpRateLimiter::new(120, 7)
    .await
    .expect("Failed to initialize IP rate limiter");

let hourly_limiter = middleware::HourlyIpLimiter::new(config.hourly_ip_limit);

HttpServer::new(move || {
    App::new()
        .wrap(ip_limiter_clone)           // 秒级限流
        .wrap(hourly_limiter.clone())     // 小时级限流
        .wrap(Governor::new(&governor_conf))
        // ...
})
```

---

## 关键代码片段

### 1. ZIP 安全提取（防止 Zip Slip 漏洞）

```rust
pub fn extract_zip_from_archive<R: std::io::Read + std::io::Seek>(
    archive: &mut ZipArchive<R>, 
    dest: &std::path::Path
) -> Result<(), Box<dyn std::error::Error>> {
    for i in 0..archive.len() {
        let mut file = archive.by_index(i)?;
        let outpath = dest.join(file.name());
        
        // 关键：检查提取路径是否仍在目标目录内
        if !outpath.starts_with(dest) {
            return Err(format!(
                "Zip slip vulnerability detected: extracted file {:?} attempts to traverse outside of destination {:?}",
                outpath, dest
            ).into());
        }

        if file.name().ends_with('/') {
            std::fs::create_dir_all(&outpath)?;
        } else {
            if let Some(p) = outpath.parent() {
                if !p.exists() {
                    std::fs::create_dir_all(p)?;
                }
            }
            let mut outfile = std::fs::File::create(&outpath)?;
            std::io::copy(&mut file, &mut outfile)?;
            
            // Unix 权限设置
            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                if let Some(mode) = file.unix_mode() {
                    let mut perms = outfile.metadata()?.permissions();
                    perms.set_mode(mode);
                    std::fs::set_permissions(&outpath, perms)?;
                }
            }
        }
    }
    Ok(())
}
```

### 2. 客户端 IP 识别

```rust
pub fn get_client_ip(req: &HttpRequest) -> String {
    // 首先尝试 peer_addr
    if let Some(addr) = req.peer_addr() {
        return addr.ip().to_string();
    }

    // 其次尝试 X-Forwarded-For 或代理信息
    if let Some(realip) = req.connection_info().realip_remote_addr() {
        if let Some((ip, _port)) = realip.rsplit_once(':') {
            if ip.contains('.') {
                return ip.to_string();
            }
        }
        return realip.to_string();
    }

    "unknown".to_string()
}
```

### 3. 进度更新

```rust
async fn update_progress(data: &Arc<AppState>, task_id: Uuid, progress: u8, step: &str) {
    if let Some(mut task) = data.tasks.get_mut(&task_id) {
        task.progress = progress;
        task.current_step = Some(step.to_string());
        task.updated_at = Utc::now();
    }

    if let Err(e) = data.database.update_task_progress(&task_id, progress, step).await {
        log::error!("Failed to update task progress: {}", e);
    }
}
```

### 4. 任务失败处理

```rust
async fn fail_task(data: &Arc<AppState>, task_id: Uuid, error_msg: String) {
    if let Some(mut task) = data.tasks.get_mut(&task_id) {
        task.status = TaskStatus::Failed;
        task.error = Some(error_msg.clone());
        task.updated_at = Utc::now();
        data.failed_tasks.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
    }

    if let Err(e) = data.database.update_task(&task).await {
        log::error!("Failed to update task: {}", e);
    }

    if let Err(e) = data.database.insert_task_event(
        &task_id, "error", Some(TaskStatus::Failed), Some(&error_msg), None
    ).await {
        log::warn!("Failed to write error event: {}", e);
    }
}
```

---

## 总结

这个项目展现了以下 Rust 最佳实践：

1. **异步编程**：tokio + async/await，充分利用 CPU
2. **并发安全**：DashMap、Arc<Mutex>、AtomicU64
3. **错误处理**：自定义错误类型、thiserror crate
4. **数据库**：SQLite + 迁移管理
5. **Web 框架**：Actix-web，中间件设计
6. **资源管理**：ZIP 嵌入、自动提取、权限设置
7. **限流防护**：多层限流、IP 封禁
8. **日志管理**：流式日志、事件记录

**代码质量指标**：
- 代码行数：~2000 行核心逻辑
- 圈复杂度：适中，易于维护
- 测试覆盖：建议补充单元测试

